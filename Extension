bhumika.si016@gmail.com

Animation
========
Bottom -> Top
———————
let transition = CATransition()
transition.duration = 0.5
transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)
transition.type = kCATransitionMoveIn
transition.subtype = kCATransitionFromTop
self.navigationController?.view.layer.add(transition, forKey: nil)
self.navigationController?.pushViewController(view controller, animated: false)

Top -> Bottom
———————
let transition = CATransition()
transition.duration = 0.5
transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)
transition.type = kCATransitionReveal
transition.subtype = kCATransitionFromBottom            
self.navigationController?.view.layer.add(transition, forKey: nil)
self.navigationController?.popViewController(animated: false)

==============================++++++++=======================================
Ads
===
import GoogleMobileAds

GADInterstitialDelegate, GADBannerViewDelegate

var bannerView: GADBannerView!
var interstitial: GADInterstitial?

interstitial = createAndLoadInterstitial()        
self.bannerAds()

//Banner and Intertial Ad
    private func createAndLoadInterstitial() -> GADInterstitial?
    {
        interstitial = GADInterstitial(adUnitID: Constants.Interstitial_Unit_Id)
        guard let interstitial = interstitial else {
            return nil
        }
        let request = GADRequest()
        interstitial.load(request)
        interstitial.delegate = self
        return interstitial
    }
    
    func interstitialDidReceiveAd(_ ad: GADInterstitial)
    {
        print("Receibed ad.")
        ad.present(fromRootViewController: self)
    }

    func interstitialDidDismissScreen(_ ad: GADInterstitial)
    {
	//
    }

    func interstitial(_ ad: GADInterstitial, didFailToReceiveAdWithError error: GADRequestError)
    {
       	print(error)
    }    

    func bannerAds()
    {
        // In this case, we instantiate the banner with desired ad size.
        bannerView = GADBannerView(adSize: kGADAdSizeBanner)
        bannerView.adUnitID = Constants.Banner_Unit_Id
        bannerView.delegate = self
        bannerView.rootViewController = self
        bannerView.load(GADRequest())
        addBannerViewToView(bannerView)
    }
    
    func addBannerViewToView(_ bannerView: GADBannerView)
    {
        bannerView.translatesAutoresizingMaskIntoConstraints = true
        bannerView.frame = CGRect(x: 0.0, y: 0.0, width: adView.frame.width, height: 50)
        adView.addSubview(bannerView)
    }
    
    func adViewDidReceiveAd(_ bannerView: GADBannerView)
    {
        // Add banner to view and add constraints as above.
        addBannerViewToView(bannerView)
    }
=================================================================================
pod 'ReachabilitySwift'
Import Reachability  
NotificationCenter.default.addObserver(self, selector: #selector(self.reachabilityChanged),name: Notification.Name.reachabilityChanged,object: reachability)
do
{
 	try reachability.startNotifier()
 }
catch
{
          print("could not start reachability notifier")
 }

//method
 @objc func reachabilityChanged(note: Notification) 
 {      
        let reachability = note.object as! Reachability        
        if reachability.isReachable 
	{
         	if reachability.isReachableViaWiFi 
		{
                	 	print("Reachable via WiFi")
            	} else {
                		print("Reachable via Cellular")
            	}
        } else {
         	print("Network not reachable")
        }
    }
=========================================================================
extension UIViewController {
    //to show toast message
    func showToast(message : String) {
        let toastLabel = UILabel(frame: CGRect(x: self.view.frame.size.width/2 - ((self.view.frame.size.width - 20)/2), y: self.view.frame.size.height-100, width: self.view.frame.size.width - 20, height: 35))
        toastLabel.backgroundColor = UIColor.black.withAlphaComponent(0.6)
        toastLabel.textColor = UIColor.white
        toastLabel.textAlignment = .center;
        toastLabel.font = UIFont(name: "Gotham-Book", size: 12.0)
        toastLabel.text = message
        toastLabel.alpha = 1.0
        toastLabel.layer.cornerRadius = 10;
        toastLabel.clipsToBounds  =  true
        self.view.addSubview(toastLabel)
        UIView.animate(withDuration: 4.0, delay: 2.0, options: .curveEaseOut, animations: {
            toastLabel.alpha = 0.0
        }, completion: {(isCompleted) in
            toastLabel.removeFromSuperview()
        })
    }
}
=========================================================================
SET FONT AND COLOR NAVIGATIONBAR TITILE

let attr = [
            NSAttributedStringKey.foregroundColor: UIColor.white,
            NSAttributedStringKey.font: UIFont(name: "Andada", size: 18)! ]
        
        UINavigationBar.appearance().titleTextAttributes = attr
=========================================================================
extension UIView {
    func roundCorners(_ corners:UIRectCorner, radius: CGFloat) {
        let path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        self.layer.mask = mask
    }
    
    func dropShadow()
    {
        self.layer.cornerRadius = 10
        self.layer.shadowColor = UIColor.black.cgColor
        self.layer.shadowOpacity = 0.5
        self.layer.shadowOffset = CGSize.zero
        self.layer.shadowRadius = 10
    }
    
    func addshadow(top: Bool, left: Bool, bottom: Bool, right: Bool, shadowRadius: CGFloat = 2.0)
    {
        self.layer.cornerRadius = 10
        self.layer.masksToBounds = false
        self.layer.shadowOffset = CGSize(width: 0.0, height: 0.0)
        self.layer.shadowRadius = shadowRadius
        self.layer.shadowOpacity = 0.5
        
        let path = UIBezierPath()
        var x: CGFloat = 0
        var y: CGFloat = 0
        var viewWidth = self.frame.width
        var viewHeight = self.frame.height
        
        // here x, y, viewWidth, and viewHeight can be changed in
        // order to play around with the shadow paths.
        if (!top) {
            y+=(shadowRadius+1)
        }
        if (!bottom) {
            viewHeight-=(shadowRadius+1)
        }
        if (!left) {
            x+=(shadowRadius+1)
        }
        if (!right) {
            viewWidth-=(shadowRadius+1)
        }
        // selecting top most point
        path.move(to: CGPoint(x: x, y: y))
        // Move to the Bottom Left Corner, this will cover left edges
        /*
         |☐
         */
        path.addLine(to: CGPoint(x: x, y: viewHeight))
        // Move to the Bottom Right Corner, this will cover bottom edge
        /*
         ☐
         -
         */
        path.addLine(to: CGPoint(x: viewWidth, y: viewHeight))
        // Move to the Top Right Corner, this will cover right edge
        /*
         ☐|
         */
        path.addLine(to: CGPoint(x: viewWidth, y: y))
        // Move back to the initial point, this will cover the top edge
        /*
         _
         ☐
         */
        path.close()
        self.layer.shadowPath = path.cgPath
    }
}
=========================================================================

Local Notification
————————-
import UserNotifications
UNUserNotificationCenterDelegate

private func scheduleLocalNotification()
    {
//        let ok = UNNotificationAction(identifier: "share", title: "Share", options: [])
//        let cancel = UNNotificationAction(identifier: "dismiss", title: "Dismiss", options: [])
//        let category = UNNotificationCategory(identifier: "message", actions: [ok, cancel], intentIdentifiers: ["share", "dismiss"], options: [])
//        UNUserNotificationCenter.current().setNotificationCategories([category])
        
        // Create Notification Content
        let notificationContent = UNMutableNotificationContent()
        var strTitle = String()
        
        // Configure Notification Content
        notificationContent.title = "goStylists!"
        //notificationContent.subtitle = "Local Notifications"
        
        if let str =  UserDefaults.standard.value(forKey: "video")
        {
            strTitle = str as! String
            UserDefaults.standard.removeObject(forKey: "video")
        }
        else if let str =  UserDefaults.standard.value(forKey: "image")
        {
            strTitle = str as! String
            UserDefaults.standard.removeObject(forKey: "image")
        }
        notificationContent.body = strTitle + " Upload Completed"
        
//        notificationContent.categoryIdentifier = "message"
        
        // Add Trigger
        let notificationTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1.0, repeats: false)
        
        // Create Notification Request
        let notificationRequest = UNNotificationRequest(identifier: "local_notification", content: notificationContent, trigger: notificationTrigger)
        
        // Add Request to User Notification Center
        UNUserNotificationCenter.current().add(notificationRequest) { (error) in
            if let error = error
            {
                print("Unable to Add Notification Request (\(error), \(error.localizedDescription))")
            }
        }
        self.appDelegate.startTimer()
    }
   
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void)
    {
        completionHandler([.alert, .sound])
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void)
    {
        if let url: String = UserDefaults.standard.value(forKey: "ReturnUrl") as? String // Fb Share Link
        {
            _ = SweetAlert().showAlert("Upload Complete", subTitle: "Generate FB Ad URL?", style: AlertStyle.success, buttonTitle:"YES", buttonColor:UIColor.colorFromRGB(0x4B7933), otherButtonTitle: "NOPE", otherButtonColor: UIColor.colorFromRGB(0x4B7933)) { (action) -> Void in
                if action == true
                {
                    
                    if (MFMessageComposeViewController.canSendText())
                    {
                        //UserDefaults.standard.removeObject(forKey: "Foreground")
                        UserDefaults.standard.removeObject(forKey: "ReturnUrl")
                        print(url)
                        let controller = MFMessageComposeViewController()
                        controller.body = url
                        controller.messageComposeDelegate = self
                        UserDefaults.standard.set(true, forKey: "LinkShare")
                        UserDefaults.standard.synchronize()
                        self.present(controller, animated: true, completion: nil)
                    }
                    
                }
                else
                {
                    UserDefaults.standard.removeObject(forKey: "ReturnUrl")
                    self.dismiss(animated: true, completion: nil)
                }
                
            }
        }
    }
====================================================================
CollectionviewcellShadow
_______________________________________________________________
cell.contentView.layer.cornerRadius = 4.0
        cell.contentView.layer.borderWidth = 1.0
        cell.contentView.layer.borderColor = UIColor.clear.cgColor
        cell.contentView.layer.masksToBounds = true
        cell.layer.shadowColor = UIColor.lightGray.cgColor
        cell.layer.shadowOffset = CGSize(width:0,height: 2.0)
        cell.layer.shadowRadius = 4.0
        cell.layer.shadowOpacity = 1.0
        cell.layer.masksToBounds = false;
        cell.layer.shadowPath = UIBezierPath(roundedRect:cell.bounds, cornerRadius:cell.contentView.layer.cornerRadius).cgPath
====================================================================
Inernetconnection
+++++++++++++
Reachability.swift
—————————
import SystemConfiguration

public class Reachability
{
    class func isConnectedToNetwork() -> Bool
    {
        var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0))
        zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress))
        zeroAddress.sin_family = sa_family_t(AF_INET)
        
        let defaultRouteReachability = withUnsafePointer(to: &zeroAddress)
        {
            $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in
                SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress)
            }
        }
        
        var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0)
        if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) == false
        {
            return false
        }
        
        let isReachable = flags == .reachable
        let needsConnection = flags == .connectionRequired
        
        return isReachable && !needsConnection
    }
}

protocol Utilities {
}

extension NSObject:Utilities{
    
    
    enum ReachabilityStatus {
        case notReachable
        case reachableViaWWAN
        case reachableViaWiFi
    }
    
    var currentReachabilityStatus: ReachabilityStatus {
        
        var zeroAddress = sockaddr_in()
        zeroAddress.sin_len = UInt8(MemoryLayout<sockaddr_in>.size)
        zeroAddress.sin_family = sa_family_t(AF_INET)
        
        guard let defaultRouteReachability = withUnsafePointer(to: &zeroAddress, {
            $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
                SCNetworkReachabilityCreateWithAddress(nil, $0)
            }
        }) else {
            return .notReachable
        }
        
        var flags: SCNetworkReachabilityFlags = []
        if !SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) {
            return .notReachable
        }
        
        if flags.contains(.reachable) == false {
            // The target host is not reachable.
            return .notReachable
        }
        else if flags.contains(.isWWAN) == true {
            // WWAN connections are OK if the calling application is using the CFNetwork APIs.
            return .reachableViaWWAN
        }
        else if flags.contains(.connectionRequired) == false {
            // If the target host is reachable and no connection is required then we'll assume that you're on Wi-Fi...
            return .reachableViaWiFi
        }
        else if (flags.contains(.connectionOnDemand) == true || flags.contains(.connectionOnTraffic) == true) && flags.contains(.interventionRequired) == false {
            // The connection is on-demand (or on-traffic) if the calling application is using the CFSocketStream or higher APIs and no [user] intervention is needed
            return .reachableViaWiFi
        }
        else {
            return .notReachable
        }
    }
    
}

Call
——-
if Reachability.isConnectedToNetwork() == true
        {
            print("Internet connection OK")
        }
        else
        {
            print("Internet connection FAILED")
            let alert = UIAlertView(title: "No Internet Connection", message: "Make sure your device is connected to the internet.", delegate: nil, cancelButtonTitle: "OK")
            alert.show()
        }

Call
——
if currentReachabilityStatus != .notReachable { }

====================================================================
Swipe Controller
============
, UIGestureRecognizerDelegate

 self.navigationController?.interactivePopGestureRecognizer?.delegate = self
        self.navigationController?.interactivePopGestureRecognizer?.isEnabled = true
====================================================================

ScreenShot
=========

func takeScreenshot(view: UIView) -> UIImage //UIImageView
    {
        UIGraphicsBeginImageContextWithOptions(view.bounds.size, false, 0)
        let context: CGContext = UIGraphicsGetCurrentContext()!
        view.layer.render(in: context)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image!
    }

====================================================================

